#!/usr/bin/env python

"""
This is the script to genearte the tercile plot based on the 
forecast(reforecast) that is generated by Andrew Ross at GFDL.

"""
from typing import (
    Literal,
    List,
    Union
)
import warnings
import numpy as np
import pandas as pd
import xarray as xr
from scipy.stats import norm as normal
from mom6.mom6_module import mom6_io

warnings.simplefilter("ignore")
xr.set_options(keep_attrs=True)

# typing
RegionalOptions = Literal[
    'MAB','GOM','SS','GB','SS_LME','NEUS_LME','SEUS_LME',
    'GOMEX','GSL','NGOMEX','SGOMEX','Antilles','Floridian'
]

class MOM6Tercile(mom6_io.MOM6Forecast):
    """
    Class for calculating tercile probability
    """
    def __init__(
            self,
            var : str,
            data_relative_dir : str = None,
            static_relative_dir  : str = None,
            tercile_relative_dir  : str = None,
            regmask_relative_dir  : str = None,
            grid : Literal['raw','regrid'] = 'raw',
            source : Literal['local','opendap'] = 'local'
    ) -> None:
        super().__init__(
            var,
            data_relative_dir,
            static_relative_dir,
            tercile_relative_dir,
            grid,
            source
        )
        self.regmask_relative_dir = regmask_relative_dir


    def calculate_tercile_prob(
        self,
        iyear : int = 1993,
        imonth: int = 3,
        lead_bins : List[int] = None,
        lead_bin : Union[int, float] = None,
        lon : Union[int, float] = None,
        lat : Union[int, float] = None
    ) -> xr.Dataset:
        """
        use single initialization's normal distribution
        and pre-defined tercile value based on the long-term 
        statistic tercile value to find the probability of
        upper ,normal , and lower tercile
        
        It also find the largest probability in upper (positive),
        normal (0), lower (negative)

        Parameters
        ----------
        lead_bins : List[int]
            The `lead_bin` used to binned the leading month result
            ex: one can set `lead_bins = [0, 3, 6, 9, 12]` for four seasonal
            mean. Default is no binning, lead_bins = None.
        
        Returns
        -------
        xr.Dataset
            two variables are in the dataset. (1) tercile_prob 
            (2) tercile_prob_max. 

            1 is a 4D matrix with the dimension 
            of lon x lat x lead x 3. This are the probability of
            upper(lon x lat x lead), normal(lon x lat x lead),
            and lower tercile(lon x lat x lead)

            2 is the 3D matrix of largest probability in upper (positive),
            normal (0), lower (negative) with dimension of (lon x lat x lead)
        """

        # loaded the mom6 raw field
        GetFcast = mom6_io.MOM6Forecast(
            var = self.var,
            data_relative_dir = self.data_relative_dir,
            static_relative_dir = self.static_relative_dir,
            tercile_relative_dir = self.tercile_relative_dir,
            grid = self.grid,
            source = self.source,
        )

        ds_data = GetFcast.get_single(
            iyear = iyear,
            imonth = imonth
        )

        # load variable to memory
        da_data = ds_data[self.var]

        if lead_bins is None:
            # average the forecast over the lead bins
            da_binned = da_data.rename({'lead': 'lead_bin'})
        else:
            # setup lead bins to average during forecast lead time
            # (should match lead bins used for the historical data
            # that created the *_terciles_*.nc
            # [0, 3, 6, 9, 12] produces 3-month averages
            lead_bin_label = np.arange(0,len(lead_bins)-1)

            # average the forecast over the lead bins
            da_binned = (
                da_data
                .groupby_bins('lead', lead_bins, labels=lead_bin_label, right=True)
                .mean('lead')
                .rename({'lead_bins': 'lead_bin'})
            )

        if lead_bin is not None:
            da_binned = da_binned.sel(lead_bin=lead_bin,method='nearest')
        if lon is not None:
            da_binned = da_binned.sel(lon=lon,method='nearest')
        if lat is not None:
            da_binned = da_binned.sel(lat=lat,method='nearest')

        # find a normal distribution for each grid cell and lead bin
        # from the ensemble mean and standard deviation
        #  this is based on 1 initialization
        da_mean = da_binned.mean('member')
        da_std = da_binned.std('member')
        da_dist = normal(loc=da_mean, scale=da_std)

        # load the predetermined reforecast/forecast tercile value
        #  this is based on 30 years statistic 1993-2023
        ds_tercile = GetFcast.get_tercile('grid')
        ds_tercile = ds_tercile.sel(init=imonth,method='nearest')

        if lead_bins is None:
            ds_tercile_binned = ds_tercile.rename({'lead': 'lead_bin'})
        else:
            # average the forecast over the lead bins
            ds_tercile_binned = (
                ds_tercile
                .groupby_bins('lead', lead_bins, labels=lead_bin_label, right=True)
                .mean('lead')
                .rename({'lead_bins': 'lead_bin'})
            )

        if lead_bin is not None:
            ds_tercile_binned = ds_tercile_binned.sel(lead_bin=lead_bin,method='nearest')
        if lon is not None:
            ds_tercile_binned = ds_tercile_binned.sel(lon=lon,method='nearest')
        if lat is not None:
            ds_tercile_binned = ds_tercile_binned.sel(lat=lat,method='nearest')

        # use single initialization's normal distribution
        # and pre-defined tercile value to find the
        # probability based on the single initialization
        # that correspond to the long-term statistic tercile value

        #---probability of lower tercile tail
        da_low_tercile_prob = xr.DataArray(
            da_dist.cdf(ds_tercile_binned['f_lowmid']),
            dims=da_mean.dims,
            coords=da_mean.coords
        )
        #---probability of upper tercile tail
        da_up_tercile_prob = 1 - xr.DataArray(
            da_dist.cdf(ds_tercile_binned['f_midhigh']),
            dims=da_mean.dims,
            coords=da_mean.coords
        )
        #---probability of between lower and upper tercile
        da_mid_tercile_prob = 1 - da_up_tercile_prob - da_low_tercile_prob

        da_tercile_prob = xr.concat(
            [da_low_tercile_prob,da_mid_tercile_prob,da_up_tercile_prob],
            pd.Index([-1,0,1],name="tercile")
        )

        # lower tercile max => negative
        # nomral tercile max => 0
        # upper tercile max => positive
        da_tercile_prob_max = (
            da_tercile_prob.idxmax(dim='tercile',fill_value=np.nan)*
            da_tercile_prob.max(dim='tercile')
        )

        # create dataset to store the tercile calculation
        ds_tercile_prob=xr.Dataset()
        ds_tercile_prob['tercile_prob'] = da_tercile_prob
        ds_tercile_prob['tercile_prob_max'] = da_tercile_prob_max

        return ds_tercile_prob

    def calculate_regional_tercile_prob(
        self,
        iyear : int = 1993,
        imonth : int = 3,
        lead_bins : List[int] = None,
        region : RegionalOptions = 'MAB'
    ) -> xr.Dataset:
        """
        Based on regional averaged value of forecast/reforecast,
        use single initialization's normal distribution
        and pre-defined tercile value based on the long-term
        statistic tercile value to find the probability of
        upper ,normal , and lower tercile

        It also find the largest probability in upper (positive),
        normal (0), lower (negative)

        Parameters
        ----------
        lead_bins : List[int]
            The `lead_bin` used to binned the leading month result
            ex: one can set `lead_bins = [0, 3, 6, 9, 12]` for four seasonal
            mean. Default is no binning, lead_bins = None.

        region_name : ({'MAB','GOM','SS','GB','SS_LME',
                        'NEUS_LME','SEUS_LME','GOMEX','GSL','NGOMEX',
                        'SGOMEX','Antilles','Floridian'), default: "MAB"
            String indicating the regional abbreviation one want to perform
            the regional averaged tercile calculation.


        Returns
        -------
        xr.Dataset
            two variables are in the dataset. (1) tercile_prob
            (2) tercile_prob_max.

            1 is a 2D matrix with the dimension
            of lead x 3. This are the probability of
            upper(lead), normal(lead), and lower tercile(lead)

            2 is the 1D array of largest probability in upper (positive),
            normal (0), lower (negative) with dimension of (lead)
        """
        # getting the regionl mask on mom grid
        ds_lme = mom6_io.MOM6Static.get_regionl_mask(self.regmask_relative_dir)

        # loaded the mom6 raw field
        GetFcast = mom6_io.MOM6Forecast(
            var = self.var,
            data_relative_dir = self.data_relative_dir,
            static_relative_dir = self.static_relative_dir,
            tercile_relative_dir = self.tercile_relative_dir,
            grid = self.grid,
            source = self.source,
        )

        ds_data = GetFcast.get_single(iyear=iyear,imonth=imonth)

        # load variable to memory
        da_data = ds_data[self.var]

        # Area weighted average to the specific region
        da_data = (
            (ds_lme[region]*da_data*ds_lme['areacello']).sum(dim=['xh','yh'])/
            (ds_lme[region]*ds_lme['areacello']).sum(dim=['xh','yh'])
        )   # if regrid of other stagger grid this need to be changed

        # setup lead bins to average during forecast lead time
        # (should match lead bins used for the historical data
        # that created the *_terciles_*.nc
        # [0, 3, 6, 9, 12] produces 3-month averages
        lead_bins = [0, 3, 6, 9, 12]
        lead_bin_label = np.arange(0,len(lead_bins)-1)

        # average the forecast over the lead bins
        da_binned = (
            da_data
            .groupby_bins('lead', lead_bins, labels=lead_bin_label, right=True)
            .mean('lead')
            .rename({'lead_bins': 'lead_bin'})
        )

        # find a normal distribution for each grid cell and lead bin
        # from the ensemble mean and standard deviation
        #  this is based on 1 initialization
        da_mean = da_binned.mean('member')
        da_std = da_binned.std('member')
        da_dist = normal(loc=da_mean, scale=da_std)

        # load the predetermined reforecast/forecast tercile value
        #  this is based on 30 years statistic 1993-2023
        ds_tercile = GetFcast.get_tercile('region')
        da_tercile = ds_tercile.sel(init=imonth,method='nearest').sel(region=region)

        # average the forecast over the lead bins
        da_tercile_binned = (
            da_tercile
            .groupby_bins('lead', lead_bins, labels=lead_bin_label, right=True)
            .mean('lead')
            .rename({'lead_bins': 'lead_bin'})
        )

        # use single initialization's normal distribution
        # and pre-defined tercile value to find the
        # probability based on the single initialization
        # that correspond to the long-term statistic tercile value

        #---probability of lower tercile tail
        da_low_tercile_prob = xr.DataArray(
            da_dist.cdf(da_tercile_binned['f_lowmid']),
            dims=da_mean.dims,
            coords=da_mean.coords
        )
        #---probability of upper tercile tail
        da_up_tercile_prob = 1 - xr.DataArray(
            da_dist.cdf(da_tercile_binned['f_midhigh']),
            dims=da_mean.dims,
            coords=da_mean.coords
        )
        #---probability of between lower and upper tercile
        da_mid_tercile_prob = 1 - da_up_tercile_prob - da_low_tercile_prob

        da_tercile_prob = xr.concat(
            [da_low_tercile_prob,da_mid_tercile_prob,da_up_tercile_prob],
            pd.Index([-1,0,1],name="tercile")
        )

        # lower tercile max => negative
        # nomral tercile max => 0
        # upper tercile max => positive
        da_tercile_prob_max = (
            da_tercile_prob.idxmax(dim='tercile',fill_value=np.nan)*
            da_tercile_prob.max(dim='tercile')
        )

        # create dataset to store the tercile calculation
        ds_tercile_prob=xr.Dataset()
        ds_tercile_prob['tercile_prob'] = da_tercile_prob
        ds_tercile_prob['tercile_prob_max'] = da_tercile_prob_max
        ds_tercile_prob['mask'] = ds_lme[region]



# finit = mom6_io.MOM6Forecast(2002,1,'tos','hindcast','static','raw','local')
# sclass = MOM6Tercile(2002,1,'tos','hindcast','tercile_calculation','static','masks','raw','local')
# sclass.calculate_regional_tercile_prob()
